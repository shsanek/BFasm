# BFASM

Это проект по генерации кода Brainfuck для исполнения ассемблера BFASM на 16-битной RAM виртуальной машине. Виртуальная машина работает с 2-байтовыми ячейками (16 бит). Для адресации доступно 2^16 ячеек или 128КБ памяти. Машина имеет 6 регистров общего назначения (r0-r5), операции для работы со стеком, команды условных переходов и базовые команды целочисленной 16-битной арифметики. Проект несет развлекательно-образовательную цель.

## BF код

[Код для BF](Sources/Products/result.bf)

## Проверенные интерпретаторы

1. [nayuki.io](https://www.nayuki.io/page/brainfuck-interpreter-javascript)
2. [brainfuck.michd.me](https://brainfuck.michd.me/) - нужно доработать что то с вводом

## Примеры программ

Встроенный в ядро ассемблер не поддерживает label. Поэтому что бы было удобно я ликую примеры с помощью `AsmBuilder`

1. [решето эратосфена](Sources/AsmBuilder/example/SieveOfEratosthenes.bfasm) - после run на вход надо подать последнее проверяемое число

## Описание команд виртуальной машины

| Команда  | Описание                                                                                  |
|----------|-------------------------------------------------------------------------------------------|
| `mov`    | Перемещает значение операнда в указанный регистр или память.                              |
| `inc`    | Увеличивает значение в указанном регистре или памяти на 1.                                |
| `dec`    | Уменьшает значение в указанном регистре или памяти на 1.                                  |
| `exit`   | Завершает выполнение с сохранением кода ошибки.                                           |
| `add`    | Складывает значение операнда с указанным регистром или памятью.                           |
| `sub`    | Вычитает значение операнда из указанного регистра или памяти и устанавливает флаги нуля и переполнения. |
| `mul`    | Умножает значение операнда на значение в указанном регистре или памяти.                   |
| `div`    | Делит значение в указанном регистре или памяти на значение операнда и пушит остаток в быстрый стек s0. |
| `cmp`    | Сравнивает значение в указанном регистре или памяти с операндом и устанавливает флаги нуля и переполнения. |
| `mod`    | Делит значение в указанном регистре или памяти на значение операнда, сохраняя остаток в регистре или памяти, а результат пушит в быстрый стек s0. |
| `jmp`    | Переходит по адресу, указанному в регистре или памяти.                                    |
| `j!=`    | Переходит по адресу, указанному в регистре или памяти, если флаг нуля не установлен.      |
| `j==`    | Переходит по адресу, указанному в регистре или памяти, если флаг нуля установлен.         |
| `j<`     | Переходит по адресу, указанному в регистре или памяти, если установлен флаг переполнения. |
| `j=>`    | Переходит по адресу, указанному в регистре или памяти, если флаг переполнения не установлен. |
| `j=<`    | Переходит по адресу, указанному в регистре или памяти, если флаг переполнения установлен или флаг нуля установлен. |
| `j>`     | Переходит по адресу, указанному в регистре или памяти, если флаг переполнения не установлен и флаг нуля не установлен. |
| `input`  | Читает входные данные и сохраняет их в указанный регистр или память.                      |
| `resIn`  | Сбрасывает флаг необходимости следующего чтения.                                          |
| `out`    | Выводит значение из указанного регистра или памяти.                                       |
| `push`   | Увеличивает стек и копирует в него значение из указанного регистра или памяти.            |
| `pop`    | Уменьшает стек и загружает из него значение в указанный регистр или память.               |
| `get`    | Загружает значение из стека с учетом смещения операнда.                                   |
| `call`   | Увеличивает стек, сохраняет текущий адрес команды в стек и переходит по адресу, указанному в регистре или памяти. |
| `ret`    | Переключает выполнение по адресу указанному в с стеке и уменьшает стек         |
| `#`      | Читает комментарий, не выполняя действия.
| `run`    | Запускает выполнение кода выше. При этом не выполняя действия в runtime. `;` - не нужна          |

### Память.

Каждая команда занимает 1 или 2 ячейки памяти(2 если есть константа). Программа будет загружена с ячейки 0. Регистр cs будет указывать на следующую за программой ячейку.

## Memory Stack

Этот стек располагается в памяти и управляется с помощью `Push` `Pop`. Стек растет в вверх. И располагается сразу за загруженной программой.
Вы можете обратиться к удаленным значениям стека используя регистр `cs`(предварительно скопировав его в общий регистр) или используя `get`.
`cs` - это указатель на голову c последним значением.

## Структура команды

Команда может иметь от 0 до 2 аргументов. Первый аргумент может быть изменен в зависимости от команды. Второй аргумент является операндом и не изменяется.

### Аргументы

Аргументы могут представлять собой:

- **Регистры**: `r0`, `r1`, `r2`, `r3`, `r4`, `r5`
- **Указатели на память** (только через регистры): `ptr r0`, `ptr r1`, `ptr r2`, `ptr r3`, `ptr r4`, `ptr r5`
- **Константы**: Десятичное число, например: `12345` увеличивает занимаемое командой место в памяти в памяти на 1. (может быть только одна на комманду)
- **Специальные значения**:
  - `cs` - Указатель на память в текущем значении стека
  - `s0` - Верхнее значение быстрого стека

### Синтаксис команды

Каждая команда должна оканчиваться точкой с запятой `;`, включая комментарии, но после служебной команды `run` `;` не нужно

### Пример команды

sub r0, r1;

## Быстрый стек

Быстрый стек — это стек в ядре (не в памяти), который содержит всего 8 16-битных значений. При переполнении этого стека значения уничтожаются безвозвратно. Некоторые команды могут сохранять дополнительные данные в этот стек, например, `mul` и `div`.

### Операции с быстрым стеком

Для операций `pop`/`push` в быстрый стек необходимо обратиться к `s0`. Если `s0` используется для чтения, происходит `pop`, если для записи — `push`.

### Примеры операций с быстрым стеком

- Команда `mov s0, 12;` выполнит `push`.
- Команда `mov r0, s0;` выполнит `pop`.
- Команда `sub s0, r1;` выполнит сначала `pop`, затем `push`.
